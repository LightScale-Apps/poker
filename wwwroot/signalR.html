<!DOCTYPE html>
<html lang="en">
  <head>
  
  </head>

  <body>

    <br><h1>message input</h1>
    <input type="text" id="messageInput" />
    <button onclick="send()">Send Message</button>
    <br><br>

    <h1>MESSAGES BELOW</h1>
    <button onclick="sr()">configure</button>
    <ul id="messagesList"></ul>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.0/signalr.min.js"></script>
    <script type="text/javascript">

function sr() {
  user.chatConnection.start();

  user.chatConnection.on("ReceiveMessage", (modelResponse) => {
    let li = document.createElement("li");
    li.textContent = `${modelResponse}`;
    document.getElementById("messagesList").appendChild(li);
  });
}

function send() {
  const str = document.getElementById("messageInput").value;
  user.chatConnection.invoke("SendMessage", str)
}

class APIConnection {
  constructor() {
    this.URL = "http://192.168.68.116:3141/";
    this.authorized = false;
    this.data = {};
    this.chatConnection = new signalR.HubConnectionBuilder().withUrl("/game").build();
  }

  async game(input) {

    if (this.chatConnection.state !== "Connected") {
      await this.chatConnection.start();
    }
    return this.chatConnection.invoke("SendMessage", input);

  }
}

user = new APIConnection();

// poker-library.js

class Card {
    constructor(rank, suit) {
        this.rank = rank;
        this.suit = suit;
    }

    toString() {
        return `${this.rank}${this.suit}`;
    }
}

class Deck {
    constructor() {
        this.reset();
    }

    reset() {
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
        const suits = ['♥', '♦', '♣', '♠'];
        this.cards = [];
        
        for (let suit of suits) {
            for (let rank of ranks) {
                this.cards.push(new Card(rank, suit));
            }
        }
    }

    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }

    draw() {
        if (this.cards.length === 0) return null;
        return this.cards.pop();
    }
}

class PokerGame {
    constructor(numPlayers) {
        this.deck = new Deck();
        this.numPlayers = numPlayers;
        this.players = Array(numPlayers).fill().map(() => ({ hand: [] }));
        this.communityCards = [];
        this.reset();
    }

    reset() {
        this.deck = new Deck();
        this.deck.shuffle();
        this.players.forEach(player => player.hand = []);
        this.communityCards = [];
    }

    dealHands() {
        // Deal two cards to each player
        for (let i = 0; i < 2; i++) {
            for (let player of this.players) {
                player.hand.push(this.deck.draw());
            }
        }
    }

    dealFlop() {
        // Burn one card and deal three cards
        this.deck.draw(); // burn
        for (let i = 0; i < 3; i++) {
            this.communityCards.push(this.deck.draw());
        }
    }

    dealTurn() {
        // Burn one card and deal one card
        this.deck.draw(); // burn
        this.communityCards.push(this.deck.draw());
    }

    dealRiver() {
        // Burn one card and deal one card
        this.deck.draw(); // burn
        this.communityCards.push(this.deck.draw());
    }

    getHandRank(cards) {
        const allCards = [...cards];
        const ranks = allCards.map(card => card.rank);
        const suits = allCards.map(card => card.suit);
        
        // Convert face cards to numerical values
        const valueMap = { 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
        const numericalRanks = ranks.map(rank => valueMap[rank] || parseInt(rank));
        
        // Check for flush
        const isFlush = suits.every(suit => suit === suits[0]);
        
        // Check for straight
        const uniqueRanks = [...new Set(numericalRanks)].sort((a, b) => a - b);
        let isStraight = false;
        if (uniqueRanks.length >= 5) {
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                if (uniqueRanks[i + 4] - uniqueRanks[i] === 4) {
                    isStraight = true;
                    break;
                }
            }
        }

        // Count frequencies of each rank
        const rankFreq = {};
        numericalRanks.forEach(rank => {
            rankFreq[rank] = (rankFreq[rank] || 0) + 1;
        });
        
        const frequencies = Object.values(rankFreq).sort((a, b) => b - a);
        const ranks_arr = Object.entries(rankFreq).sort((a, b) => b[1] - a[1] || b[0] - a[0]);

        // Determine hand rank
        if (isFlush && isStraight) return { rank: 8, name: 'Straight Flush' }; // Straight Flush
        if (frequencies[0] === 4) return { rank: 7, name: 'Four of a Kind' }; // Four of a Kind
        if (frequencies[0] === 3 && frequencies[1] === 2) return { rank: 6, name: 'Full House' }; // Full House
        if (isFlush) return { rank: 5, name: 'Flush' }; // Flush
        if (isStraight) return { rank: 4, name: 'Straight' }; // Straight
        if (frequencies[0] === 3) return { rank: 3, name: 'Three of a Kind' }; // Three of a Kind
        if (frequencies[0] === 2 && frequencies[1] === 2) return { rank: 2, name: 'Two Pair' }; // Two Pair
        if (frequencies[0] === 2) return { rank: 1, name: 'One Pair' }; // One Pair
        return { rank: 0, name: 'High Card' }; // High Card
    }

    determineWinner() {
        const playerHands = this.players.map((player, index) => {
            const allCards = [...player.hand, ...this.communityCards];
            const handRank = this.getHandRank(allCards);
            return {
                playerIndex: index,
                hand: player.hand,
                handRank: handRank
            };
        });

        // Sort by hand rank (higher is better)
        playerHands.sort((a, b) => b.handRank.rank - a.handRank.rank);

        return {
            winningPlayer: playerHands[0].playerIndex,
            winningHand: playerHands[0].handRank.name,
            allHands: playerHands
        };
    }

    calculateOdds() {
        const remainingCards = [...this.deck.cards];
        const iterations = 1000; // Monte Carlo simulation iterations
        const wins = Array(this.numPlayers).fill(0);

        for (let i = 0; i < iterations; i++) {
            // Create a copy of the current game state
            const simulatedCommunityCards = [...this.communityCards];
            const remainingCardsCopy = [...remainingCards];

            // Complete the community cards if needed
            while (simulatedCommunityCards.length < 5) {
                const randomIndex = Math.floor(Math.random() * remainingCardsCopy.length);
                simulatedCommunityCards.push(remainingCardsCopy[randomIndex]);
                remainingCardsCopy.splice(randomIndex, 1);
            }

            // Determine winner for this simulation
            const winner = this.determineWinner();
            wins[winner.winningPlayer]++;
        }

        // Calculate odds for each player
        return this.players.map((_, index) => ({
            playerIndex: index,
            winningOdds: (wins[index] / iterations * 100).toFixed(2) + '%'
        }));
    }
}

class PokerVisualizer {
    static cardToString(card) {
        if (!card) return '┌─────┐\n│     │\n│  ?  │\n│     │\n└─────┘';
        const { rank, suit } = card;
        return [
            '┌─────┐',
            `│${rank.padEnd(2)}   │`,
            `│  ${suit}  │`,
            `│   ${rank.padStart(2)}│`,
            '└─────┘'
        ].join('\n');
    }

    static combineLinesOfCards(cards) {
        if (!cards.length) return '';
        const cardStrings = cards.map(card => this.cardToString(card).split('\n'));
        const numLines = cardStrings[0].length;
        let result = '';
        
        for (let i = 0; i < numLines; i++) {
            result += cardStrings.map(card => card[i]).join(' ') + '\n';
        }
        
        return result;
    }

    static visualize(game, showAllCards = false) {
        const { players, communityCards } = game;
        let output = '\n';

        // Add separator line
        output += '═'.repeat(80) + '\n\n';

        // Display players' hands
        players.forEach((player, index) => {
            const isCurrentPlayer = index === 0;
            const shouldShowCards = showAllCards || isCurrentPlayer;
            output += `Player ${index + 1}'s hand:\n`;
            output += this.combineLinesOfCards(shouldShowCards ? player.hand : [null, null]);
            output += '\n';
        });

        // Add separator line
        output += '═'.repeat(80) + '\n';

        // Display community cards
        output += '\nCommunity Cards:\n';
        output += this.combineLinesOfCards(communityCards);
        
        // If there are fewer than 5 community cards, show placeholders
        const remainingCards = 5 - communityCards.length;
        if (remainingCards > 0) {
            output += this.combineLinesOfCards(Array(remainingCards).fill(null));
        }

        // Add separator line
        output += '\n' + '═'.repeat(80) + '\n';

        return output;
    }

    static visualizeWithStats(game, showAllCards = false) {
        let output = this.visualize(game, showAllCards);
        
        // Add game statistics
        if (game.communityCards.length === 5) {
            const winner = game.determineWinner();
            output += `\nWinner: Player ${winner.winningPlayer + 1} with ${winner.winningHand}\n`;
        }

        // Calculate and display odds if there are community cards but the river hasn't been dealt
        if (game.communityCards.length > 0 && game.communityCards.length < 5) {
            const odds = game.calculateOdds();
            output += '\nCurrent winning odds:\n';
            odds.forEach(({ playerIndex, winningOdds }) => {
                output += `Player ${playerIndex + 1}: ${winningOdds}\n`;
            });
        }

        return output;
    }
}

  </script>
  </body>
</html>
